;;; Forth-itc-metacompiler-forthcode.lisp -- Forth ITC MetaCompiler Forth Code
;; DM/Acudora  10/12

;; This file should be manually loaded by the application code to be
;; meta-compiled

;; ------------------------------------------------------------------
(in-package #:forthrpl)
;; ------------------------------------------------------------------
(setf *meta-present* t) ;; activate metacompiler overrides
;; ----------------------------------------------------------
;; MetaCompiler Support

;; -----------------------------------------------------
;; reset the meta vocabulary and the metacompiler tables
(interpret #>.end
  forth definitions
  forget meta
  vocabulary meta
  meta definitions
.end)
(init-meta-kernel)

;; -----------------------------------------------------

(define-unary-fops
   (fabs  abs)
   (fsqrt sqrt)
   (fsin  sin)
   (fcos  cos)
   (ftan  tan)
   (fasin asin)
   (facos acos)
   (fatan atan)
   (flog  log)
   (fexp  exp)
   (finv  /)
   (fneg -)
   (frealpart realpart)
   (fimagpart imagpart))

(define-unary-fcompares
   (f0=       zerop)
   (f0<       minusp)
   (f0>       plusp)
   (f0/=      not-zerop)
   (ftruncate truncate)
   (fround    round)
   (ffloor    floor)
   (fceiling  ceiling))

(define-binary-fops
 (f+ +)
 (f- -)
 (f* *)
 (f/ /)
 (fexpt    expt)
 (flogb    log)
 (fatan2   atan)
 (fcomplex complex)
 (fmod     mod)
 (frem     rem)
 (fmin     min)
 (fmax     max))

(define-binary-fcompares
 (f=       =)
 (f<       <)
 (f<=      <=)
 (f>       >)
 (f>=      >=)
 (f/=      /=))

(interpret #>.end
  : cls  cls
         code{ (setf *fstack* nil) } ;

  code fliteral
    (push (pop *reg-i*) *fstack*) }
    
  code float
      (push (dfloat (pop *pstack*)) *fstack*) }

  code faref
    (let* ((off (pop *pstack*))
           (arr (pop *pstack*)))
      (push (aref arr off) *fstack*)) }

  code fswap
    (let* ((op1 (pop *fstack*))
           (op2 (pop *fstack*)))
      (push op1 *fstack*)
      (push op2 *fstack*)) }

  code fover
    (let* ((op2 (pop *fstack*))
           (op1 (car *fstack*)))
      (push op2 *fstack*)
      (push op1 *fstack*)) }

  code fdup
    (push (car *fstack*) *fstack*) }

  code fdrop
    (pop *fstack*) }

  code frot
    (let* ((op3 (pop *fstack*))
           (op2 (pop *fstack*))
           (op1 (pop *fstack*)))
      (push op2 *fstack*)
      (push op3 *fstack*)
      (push op1 *fstack*)) }

  code -frot
    (let* ((op3 (pop *fstack*))
           (op2 (pop *fstack*))
           (op1 (pop *fstack*)))
      (push op3 *fstack*)
      (push op1 *fstack*)
      (push op2 *fstack*)) }
    
  code fpick
    (let ((ix (pop *pstack*)))
      (push (elt *fstack* ix) *fstack*)) }

  code /
    ;; make integer division truncating
    (let ((den (pop *pstack*)))
      (setf (car *pstack*) (truncate (car *pstack*) den))) }

  ;; careful here...
  code fpop
    (push (pop *fstack*) *pstack*) }

  code fpush
    (push (pop *pstack*) *fstack*) }

  : 2fdrop  fdrop fdrop ;
  : 2fdup   fover fover ;
  : f.      fpop . ;

  ;; --------------------------------------------------------------------------

  code ,
    (mcompile (pop *pstack*)) }

  code here
    (push (mhere) *pstack*) }

  code !dp
    (let ((pos (pop *pstack*)))
      (when (>= pos (array-total-size *fmem*))
        (adjust-array *fmem* (+ pos 4096)
                      :initial-element 0))
      (setf (fill-pointer *fmem*) pos)) }

  code (align)
    (let ((nw (pop *pstack*)))
      (pad-fmem-table nw)) }

  code compile
    (mcompile (mw-mfa (car *reg-i*)))
    (setf *reg-i* (cdr *reg-i*)) }

  code assemble-float
    (let* ((lo (pop *pstack*))
           (hi (pop *pstack*)))
      (fli:with-dynamic-foreign-objects ((x double-bits))
        (setf (fli:foreign-slot-value x '(i h)) hi
              (fli:foreign-slot-value x '(i l)) lo)
        (push (fli:foreign-slot-value x 'd) *fstack*))) }

  code split-float
    (let ((d (pop *fstack*)))
      (fli:with-dynamic-foreign-objects ((x double-bits))
        (setf (fli:foreign-slot-value x 'd) d)
        (push (fli:foreign-slot-value x '(i h)) *pstack*)
        (push (fli:foreign-slot-value x '(i l)) *pstack*)) ) }

  code f,
    (fli:with-dynamic-foreign-objects ((x double-bits))
      (setf (fli:foreign-slot-value x 'd) (pop *fstack*))
      (mcompile (fli:foreign-slot-value x '(i h)))
      (mcompile (fli:foreign-slot-value x '(i l)))) }
.end)

;; --------------------------------------------------------------

;; ------------------------------------------------------
;; CRPL Target Declarations

(c-code #>.end
// VTuning-FCode.cpp -- ITC Forth implementation of VTuning
// DM/Acudora  11/11
//
// Code generated by Lisp ITC-MetaForth Compiler
// --------------------------------------------------------

#include <math.h>

// for WIN32
typedef long     int32;
typedef unsigned long uint32;
typedef float    float32;
typedef double   float64;

typedef union
{
   float64 d;
   int32   i[2];
} dbl_int_t;

inline float64 round(float64 x)
{
  if(x < 0.0)
    return ceil(x-0.5);
  else
    return floor(x+0.5);
}

// ---------------------------------------------------------------------------------------------
int32   f_sstack[1024];
int32   f_rstack[1024];
float64 f_fstack[64];

int32 f_reg_s = 0;
int32 f_reg_r = 0;
int32 f_reg_f = 0;
int32 f_reg_i = 0;
int32 f_reg_w = 0;

#define tos   f_sstack[f_reg_s-1]
#define nos   f_sstack[f_reg_s-2]
#define nnos  f_sstack[f_reg_s-3]

#define rtos  f_rstack[f_reg_r-1]
#define rnos  f_rstack[f_reg_r-2]

#define nxtop f_mem[f_reg_i++]

#define ftos  f_fstack[f_reg_f-1]
#define fnos  f_fstack[f_reg_f-2]
#define fnnos f_fstack[f_reg_f-3]

inline void _f_rpush(int32 x)
{
  f_rstack[f_reg_r++] = x;
}

inline int32 _f_rpop()
{
  return f_rstack[--f_reg_r];
}

inline void _f_spush(int32 x)
{
  f_sstack[f_reg_s++] = x;
}

inline int32 _f_spop()
{
  return f_sstack[--f_reg_s];
}

inline void _f_fpush(float64 x)
{
  f_fstack[f_reg_f++] = x;
}

inline float64 _f_fpop()
{
  return f_fstack[--f_reg_f];
}

.end)

;; --------------------------------------------
(c-code "") ;; leave room for f_mem table here
;; --------------------------------------------

;; -------------------------------------------------
;; Simulation support

(interpret #>.end
  code fmem
    (push *fmem* *pstack*) }

  code m_funcs
    (push *m_funcs* *pstack*) }

  code show-meta
    (let ((w (pop *pstack*)))
      (format t "~%metax: ~A " (fw-nfa w))) }

  code show-meta-word
    (let* ((off  (pop *pstack*))
           (w    (um:nlet iter ((w (last-def)))
                   (when w
                     (if (and (subtypep (type-of w) '<meta-def>)
                              (= off (mw-mfa w)))
                         w
                       (iter (fw-lfa w)))) )))
      (format t "~%m: ~A " (fw-nfa w))) }
    
  ;; -----------------------------------------------------
  ;; Meta-Engine Simulator Description in RPL

  0 variable m_reg_i
  0 variable m_reg_w
  0 variable m_reg_r
  1024 array m_rstack
    
  : @mem  fmem swap i@ ;
  : !mem  fmem swap i! ;

  : rpush    m_rstack m_reg_r @++ i! ;
  : rpop     m_rstack m_reg_r --@ i@ ;
  : next-op  m_reg_i @++ @mem ;

  : meta-step
    ;; dup show-meta-word 
    m_funcs swap
    dup 1+ m_reg_w !
    @mem i@
    execute ;

  : meta-inner
     begin
       meta-step
       m_reg_i @ 0/=
     while
       next-op
       ;; dup . space
     repeat ;

  : meta-interpret ( wd t/f -- )
      ?dup
      if   swap drop code{ (meta-handle-found (pop *pstack*)) }
      else code{ (meta-handle-not-found (pop *pstack*)) }
      then ;

  ;; : outer-meta begin bl-word find meta-interpret again ;
  : outer-meta begin bl-word ?dup while find meta-interpret repeat quit ;

  .end)

;; -------------------------------------------------
;; Fundamental Metacode Behaviors
;; -------------------------------------------------

(mcode "(colon)"
       :cname f_docol
       :ccode #>.end
       _f_rpush(f_reg_i);
       f_reg_i = f_reg_w;
       .end
       :does "{ m_reg_i @ rpush
              m_reg_w @ m_reg_i ! }")

(mcode "(variable)"
       :cname f_dovar
       :ccode #>.end
       _f_spush(f_reg_w);
       .end
       :does "{ m_reg_w @ }")

(mcode "(constant)"
       :cname f_doconst
       :ccode #>.end
       _f_spush(f_mem[f_reg_w]);
       .end
       :does "{ m_reg_w @ @mem }")

(mcode "(fconstant)"
       :cname f_dofconst
       :ccode #>.end
       dbl_int_t xd;
       xd.i[0] = f_mem[f_reg_w++];
       xd.i[1] = f_mem[f_reg_w];
       _f_fpush(xd.d);
       .end
       :does "{ m_reg_w @ dup @mem
              swap 1+ @mem
              assemble-float }")

(mcode "(field)"
       :cname f_dofield
       :ccode #>.end
       tos += f_mem[f_reg_w];
       .end
       :does "{ m_reg_w @ @mem + }")

(mcode "(does)"
       :cname f_dodoes
       :ccode #>.end
       _f_rpush(f_reg_i);
       f_reg_i = f_mem[f_reg_w++];
       _f_spush(f_reg_w);
       .end
       :does "{ m_reg_i @ rpush
               m_reg_w @ dup @mem m_reg_i !
               1+ }")

(mcode "(exit)"
       :cname f_doexit
       :ccode #>.end
       f_reg_i = _f_rpop();
       .end
       :does "{ rpop m_reg_i ! }")

(mcode "(literal)"
       :cname f_dolit
       :ccode #>.end
       _f_spush(nxtop);
       .end
       :does "{ next-op }")

(mcode "(fliteral)"
       :cname f_dodlit
       :ccode #>.end
       dbl_int_t xd;
       xd.i[0] = nxtop;
       xd.i[1] = nxtop;
       _f_fpush(xd.d);
       .end
       :does "{ next-op next-op assemble-float }")

(mcode "[']"
       :cname f_dodfa
       :ccode #>.end
       _f_spush(1+nxtop);
       .end
       :does "{ next-op 1+ }")

(mcode "(if)"
       :cname f_doif
       :ccode #>.end
       if(_f_spop())
         ++f_reg_i;
       else
         f_reg_i = f_mem[f_reg_i];
       .end
       :does "{ next-op swap if drop else m_reg_i ! then }")

(mcode "(jmp)"
       :cname f_dojmp
       :ccode #>.end
       f_reg_i = f_mem[f_reg_i];
       .end
       :does "{ next-op m_reg_i ! }")

(mcode "(do)"
       :cname f_dodo
       :ccode #>.end
       int32 ix  = _f_spop();
       int32 lim = _f_spop();
       _f_rpush(lim);
       _f_rpush(ix);
       .end
       :does "{ swap rpush rpush }")

(mcode "(loop)"
       :cname f_doloop
       :ccode #>.end
       int32 ix = ++rtos;
       if(ix < rnos)
         f_reg_i = f_mem[f_reg_i];
       else
       {
         f_reg_r -= 2;
         ++f_reg_i;
       }
       .end
       :does "{ next-op
              rpop 1+ rpop
              2dup < if rpush rpush m_reg_i !
              else 2drop drop then }")

(setf *tic-meta-inner*  (must-find 'meta-inner)
      *tic-meta-step*   (must-find 'meta-step)
      *tic-meta-lit64f* (must-find "(fliteral)")
      *tic-meta-lit32i* (must-find "(literal)")
      *tic-flit*        (must-find 'fliteral)
      *tic-outer-meta*  (must-find 'outer-meta))

;; -------------------------------------------------

(interpret #>.end
           
  code ifa
    (let ((w (pop *pstack*)))
      (push (mw-mfa w) *pstack*)) }

  code dfa
    (let ((w (pop *pstack*)))
      (push (1+ (mw-mfa w)) *pstack*)) }

  code mfa
    (let ((w (pop *pstack*)))
      (push (mw-mfa w) *pstack*)) }

  code make-meta-word
    (let* ((h (pop *pstack*)))
      (push (derive-word '<meta-def>
                         :cfa #'(lambda (self)
                                  (push (mw-mfa self) *pstack*)
                                  (execute-word *tic-meta-inner*))
                         :mfa h)
            *pstack*)) }

  code show-stack
    (inspect (copy-seq *pstack*)) }

  code tell-defining
    (format t "~%defining: ~A" (car *pstack*)) }

  code does
    (let ((w (pop *reg-i*)))
      (mcompile (aref *fmem* (mw-mfa w)))) }

  ;; -----------------------------------------------------
  ;; Meta-Interpreter

  code .stack
    ;; check on stack cleanliness during meta-compile
    (let ((*print-base* (@fcell *base*)))
      (format t "~%------------------")
      (format t "~%pstack = ~A" (reverse *pstack*))
      (format t "~%fstack = ~A" (reverse *fstack*))
      (format t "~%------------------")
      (terpri)) } immediate
  : .s  [compile] .stack ; immediate
  
  ;; -----------------------------------------------------
  ;; MetaCompiler Code

  : [show-stack] show-stack ; immediate
  : align ( n -- ensure that next dfa is aligned on nbyte boundary )
       4 / 1- dup here and -
       ?dup if
          0 do 0 , loop
       then ; 
  : hfs      here swap ;
  : show-def-meta  ." m: " . space ;
  : mmw     make-meta-word
       bl-word
       dup show-def-meta
       def ;

  : '  bl-word must-find mfa 1+ ;
  : cfa  1- ;

  0 variable current-template
  : variable  hfs does (variable) , mmw ;
  : constant  hfs does (constant) , mmw ;
  : fvariable here does (variable) f, mmw ;
  : fconstant here does (fconstant) f, mmw ;
  : structure-template 0 constant here 1- current-template ! ;
  : make-field current-template @ @mem dup rot + current-template @ !mem
               hfs does (field) , mmw ;
  : field     1 make-field ;
  : ffield    2 make-field ;

  : allot     here + !dp ;
  : array     hfs does (variable) allot mmw ;

  : fcells    2 * ;
  : fallot    fcells allot ;
  : farray    hfs does (variable) fallot mmw ;

  : if     compile (if) here 0 , ; immediate
  : else   compile (jmp) here 0 , here rot !mem ; immediate
  : then   hfs !mem ; immediate
  : do     compile (do) here ; immediate
  : loop   compile (loop) , ; immediate
  : begin  here ; immediate
  : again  compile (jmp) , ; immediate
  : until  compile (if) , ; immediate
  : while  compile (if) here swap 0 , ; immediate
  : repeat compile (jmp) , here swap !mem ; immediate

  : ;     compile (exit)
          [compile] [
          make-meta-word
          swap def
          set-current-context ; immediate
          
  : :     set-current-context
          bl-word
          dup show-def-meta
          here
          does (colon)
          ] forth ;
  .end)

;; -----------------------------------------------------


